# veeam-signature

## Входные данные

- --input=<path> - путь до хешируемого файла
- --output=<path> - путь до файла подписи
- --chunk_size=<size> - размер блока, опционален. допустимо указывать суффиксом единицу измерения, например 4Mib
- допустимые размеры блоков - 64Kb - 8Mb


## Решаемые проблемы

### Проблема выходного файла (внезапно первая)

Поскольку минимальный размер блока 64Kb, то количество чанков для файла размером в 1Tb будет 15_625_000.
При размере записи хеша одного чанка к примеру в 100 байт(с запасом), общий размер выходного файла составит 15_625_000 * 100B / 1_000_000B = 1562,4Mb.
Таким образом, проблемы нет, и собрать все хеши чанков можно в памяти =). 

### Проблема чтения файла не помещающегося в RAM

Есть несколько вариантов решения:

- Сделать mmap, читать последовательно чанками, раскидывать их задачами на тредпул, потом сбрасывать на выход по готовности чанка, сортировать, писать в файл.
Плюсы: ничего не копируется, чтение строго последовательное (привет hdd). 
Минусы: постоянные page fault, но которые вроде как не критичные(надо разбираться)

- Сделать mmap, порезать на блоки строго по количеству ядер, потом сбрасывать на выход по готовности блока, сортировать, писать в файл.
Плюсы: ничего не копируется, чтение строго последовательные по блокам(непонятно, хорошо или так себе)
Минусы: больше page fault, доступ уже все таки не линейный а произвольный

- Делать read, читать большими буферами (100mb), раскидывать на тредпул и т.д. как в первом варианте
Плюсы: строго линейное чтение, теоретически быстрее mmap
Минусы: копирование в юзерленд, но вроде довольно оптимальное

- Делать read, читать большими буферами (100mb), поделить файл на блоки, читать считать каждый своим потоком.
 Плюсы: чтение линейное в рамках потока
 Минусы: копирование в юзерленд, но вроде довольно оптимальное

В итоге сделан второй вариант, но в целом нужны более явные границы задачи, после чего нормальные измерения в ее границах


## Резюме

Задача решена в лоб, и именно в рамках ТЗ, но в целом более универсально было бы собрать конвеер чтения-обработки-записи.
Например, по принципу producer-consumer с использованием к примеру boost::asio.

Смарт-пойнтеры не потребовались =)